name: Sync PR Comment to Linked Issue

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  pull-requests: read

jobs:
  update-issue:
    if: github.event.issue.pull_request != null
    runs-on: ubuntu-latest
    
    steps:
      - name: Sync comment to linked issue
        uses: actions/github-script@v7
        with:
          script: |
            const commenter = context.payload.comment.user.login;
            const commenterType = context.payload.comment.user.type;
            
            // Exclude bot accounts
            const excludedBots = [
              'github-actions[bot]',
              'github-actions',
              'copilot'
            ];
            
            const isBot = commenterType === 'Bot' || 
                         excludedBots.some(bot => commenter.toLowerCase().includes(bot.toLowerCase()));
            
            if (isBot) {
              core.info(`Skipping bot comment from ${commenter}`);
              return;
            }

            // Get PR details
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.issue.number
            });

            // Collect all linked issues
            const linkedIssueNumbers = new Set();
            
            // Search for keyword-based links in PR title and body
            const text = `${pr.data.title}\n\n${pr.data.body || ''}`;
            const keywordMatches = text.matchAll(/(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s+#(\d+)/gi);
            for (const match of keywordMatches) {
              linkedIssueNumbers.add(match[1]);
            }
            
            // Use GraphQL to get ALL linked issues (including manually linked ones)
            try {
              const query = `
                query($owner: String!, $repo: String!, $number: Int!) {
                  repository(owner: $owner, name: $repo) {
                    pullRequest(number: $number) {
                      closingIssuesReferences(first: 50) {
                        nodes {
                          number
                        }
                      }
                    }
                  }
                }
              `;
              
              const result = await github.graphql(query, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                number: context.payload.issue.number
              });
              
              const graphqlIssues = result.repository.pullRequest.closingIssuesReferences.nodes;
              for (const issue of graphqlIssues) {
                linkedIssueNumbers.add(issue.number.toString());
              }
            } catch (error) {
              core.warning(`Could not fetch linked issues via GraphQL: ${error.message}`);
            }
            
            if (linkedIssueNumbers.size === 0) {
              core.info('No linked issues found.');
              return;
            }

            core.info(`Syncing comment to ${linkedIssueNumbers.size} linked issue(s): ${Array.from(linkedIssueNumbers).join(', ')}`);

            // Sync comment to ALL linked issues
            for (const issueNumber of linkedIssueNumbers) {
              try {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: Number(issueNumber),
                  body: `↩️ **Update from [PR #${context.payload.issue.number}](${pr.data.html_url})**\n\n> ${context.payload.comment.body.trim()}\n\n_Comment by [@${context.payload.comment.user.login}](${context.payload.comment.user.html_url})_`
                });
              } catch (error) {
                core.error(`Failed to sync to issue #${issueNumber}: ${error.message}`);
              }
            }