name: Sync PR Comment to Linked Issue

on:
  issue_comment:
    types: [created, edited, deleted]
  pull_request:
    types: [edited]
  pull_request_review:
    types: [submitted, edited, dismissed]

permissions:
  issues: write
  pull-requests: read

jobs:
  sync:
    runs-on: ubuntu-latest
    
    steps:
      - name: Sync to linked issues
        uses: actions/github-script@v7
        with:
          script: |
            async function getLinkedIssues(prNumber) {
              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              const linkedIssues = new Set();
              const text = pr.data.body || '';
              const keywordMatches = text.matchAll(/(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s+#(\d+)/gi);
              for (const match of keywordMatches) linkedIssues.add(match[1]);
              
              try {
                const result = await github.graphql(`
                  query($owner: String!, $repo: String!, $number: Int!) {
                    repository(owner: $owner, name: $repo) {
                      pullRequest(number: $number) {
                        closingIssuesReferences(first: 50) { nodes { number } }
                      }
                    }
                  }
                `, { owner: context.repo.owner, repo: context.repo.repo, number: prNumber });
                
                for (const issue of result.repository.pullRequest.closingIssuesReferences.nodes) {
                  linkedIssues.add(issue.number.toString());
                }
              } catch (error) {
                core.warning(`GraphQL error: ${error.message}`);
              }

              return { pr, linkedIssues };
            }

            async function findSyncedComment(issueNumber, marker) {
              let page = 1;
              while (page <= 10) {
                const comments = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: Number(issueNumber),
                  per_page: 100,
                  page: page
                });
                
                if (comments.data.length === 0) break;
                const found = comments.data.find(c => c.body?.includes(marker));
                if (found) return found;
                if (comments.data.length < 100) break;
                page++;
              }
              return null;
            }

            async function syncToIssues(prNumber, linkedIssues, text, marker, label, author, isEdit, commentUrl) {
              if (!text.trim()) return core.info('Skipping empty text');
              
              const quotedBody = text.split('\n').map(line => `> ${line}`).join('\n');
              const prLink = commentUrl || `https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prNumber}`;
              const commentBody = `↩️ **${label} [PR #${prNumber}](${prLink})**\n\n${quotedBody}\n\n_By [@${author.login}](${author.html_url})${isEdit ? ' (edited)' : ''}_\n\n${marker}`;

              for (const issueNumber of linkedIssues) {
                try {
                  const existing = await findSyncedComment(issueNumber, marker);
                  if (existing) {
                    await github.rest.issues.updateComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: existing.id,
                      body: commentBody
                    });
                    core.info(`Updated issue #${issueNumber}`);
                  } else {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: Number(issueNumber),
                      body: commentBody
                    });
                    core.info(`Created on issue #${issueNumber}`);
                  }
                } catch (error) {
                  core.error(`Failed for issue #${issueNumber}: ${error.message}`);
                }
              }
            }

            // Handle PR description edit
            if (context.eventName === 'pull_request' && context.payload.changes?.body) {
              const prNumber = context.payload.pull_request.number;
              const { pr, linkedIssues } = await getLinkedIssues(prNumber);
              if (linkedIssues.size === 0) return core.info('No linked issues');
              
              await syncToIssues(
                prNumber, linkedIssues, pr.data.body || '',
                `<!-- pr-description-sync: ${prNumber} -->`,
                'PR Description from', pr.data.user, true
              );
              return;
            }

            // Handle PR comment and review events
            const excludedBots = ['github-actions[bot]', 'github-actions', 'copilot'];
            let user, body, itemId, prNumber, htmlUrl, label;

            if (context.eventName === 'issue_comment' && context.payload.issue.pull_request) {
              user = context.payload.comment.user;
              body = context.payload.comment.body || '';
              itemId = context.payload.comment.id;
              prNumber = context.payload.issue.number;
              htmlUrl = context.payload.comment.html_url;
              label = 'Update from';
            } else if (context.eventName === 'pull_request_review') {
              user = context.payload.review.user;
              body = context.payload.review.body || '';
              itemId = context.payload.review.id;
              prNumber = context.payload.pull_request.number;
              htmlUrl = context.payload.review.html_url;
              label = 'Review from';
            } else {
              return;
            }

            // Skip bots
            if (user.type === 'Bot' || excludedBots.some(bot => user.login.toLowerCase().includes(bot.toLowerCase()))) {
              return core.info(`Skipping bot: ${user.login}`);
            }

            // Only process content that contains "issue:" or "ticket:" (case-insensitive)
            if (!/\b(issue|ticket):/i.test(body)) {
              return core.info('Content does not contain issue: or ticket:');
            }

            const { pr, linkedIssues } = await getLinkedIssues(prNumber);
            if (linkedIssues.size === 0) return core.info('No linked issues');

            const marker = `<!-- pr-${context.eventName === 'pull_request_review' ? 'review' : 'comment'}-sync: ${itemId} -->`;

            // Handle delete/dismiss
            if (context.payload.action === 'deleted' || context.payload.action === 'dismissed') {
              for (const issueNumber of linkedIssues) {
                try {
                  const synced = await findSyncedComment(issueNumber, marker);
                  if (synced) {
                    await github.rest.issues.deleteComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: synced.id
                    });
                    core.info(`Deleted from issue #${issueNumber}`);
                  }
                } catch (error) {
                  core.error(`Delete failed for issue #${issueNumber}: ${error.message}`);
                }
              }
              return;
            }

            // Handle create/edit/submit
            await syncToIssues(
              prNumber, linkedIssues, body,
              marker, label, user, context.payload.action === 'edited',
              htmlUrl
            );