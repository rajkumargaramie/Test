name: Sync PR Comment to Linked Issue

on:
  issue_comment:
    types: [created, edited, deleted]
  pull_request:
    types: [edited]

permissions:
  issues: write
  pull-requests: read

jobs:
  sync:
    runs-on: ubuntu-latest
    
    steps:
      - name: Sync to linked issues
        uses: actions/github-script@v7
        with:
          script: |
            async function getLinkedIssues(prNumber) {
              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              const linkedIssues = new Set();
              const text = pr.data.body || '';
              const keywordMatches = text.matchAll(/(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s+#(\d+)/gi);
              for (const match of keywordMatches) linkedIssues.add(match[1]);
              
              try {
                const result = await github.graphql(`
                  query($owner: String!, $repo: String!, $number: Int!) {
                    repository(owner: $owner, name: $repo) {
                      pullRequest(number: $number) {
                        closingIssuesReferences(first: 50) { nodes { number } }
                      }
                    }
                  }
                `, { owner: context.repo.owner, repo: context.repo.repo, number: prNumber });
                
                for (const issue of result.repository.pullRequest.closingIssuesReferences.nodes) {
                  linkedIssues.add(issue.number.toString());
                }
              } catch (error) {
                core.warning(`GraphQL error: ${error.message}`);
              }

              return { pr, linkedIssues };
            }

            async function findSyncedComment(issueNumber, marker) {
              let page = 1;
              while (page <= 10) {
                const comments = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: Number(issueNumber),
                  per_page: 100,
                  page: page
                });
                
                if (comments.data.length === 0) break;
                const found = comments.data.find(c => c.body?.includes(marker));
                if (found) return found;
                if (comments.data.length < 100) break;
                page++;
              }
              return null;
            }

            async function syncToIssues(prNumber, linkedIssues, text, marker, label, author, isEdit) {
              if (!text.trim()) return core.info('Skipping empty text');
              
              const quotedBody = text.split('\n').map(line => `> ${line}`).join('\n');
              const commentBody = `↩️ **${label} [PR #${prNumber}](${author.html_url})**\n\n${quotedBody}\n\n_By [@${author.login}](${author.html_url})${isEdit ? ' (edited)' : ''}_\n\n${marker}`;

              for (const issueNumber of linkedIssues) {
                try {
                  const existing = await findSyncedComment(issueNumber, marker);
                  if (existing) {
                    await github.rest.issues.updateComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: existing.id,
                      body: commentBody
                    });
                    core.info(`Updated issue #${issueNumber}`);
                  } else {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: Number(issueNumber),
                      body: commentBody
                    });
                    core.info(`Created on issue #${issueNumber}`);
                  }
                } catch (error) {
                  core.error(`Failed for issue #${issueNumber}: ${error.message}`);
                }
              }
            }

            // Handle PR description edit
            if (context.eventName === 'pull_request' && context.payload.changes?.body) {
              const prNumber = context.payload.pull_request.number;
              const { pr, linkedIssues } = await getLinkedIssues(prNumber);
              if (linkedIssues.size === 0) return core.info('No linked issues');
              
              await syncToIssues(
                prNumber, linkedIssues, pr.data.body || '',
                `<!-- pr-description-sync: ${prNumber} -->`,
                'PR Description from', pr.data.user, true
              );
              return;
            }

            // Handle comment events
            if (context.eventName !== 'issue_comment' || !context.payload.issue.pull_request) return;

            const commenter = context.payload.comment.user;
            const excludedBots = ['github-actions[bot]', 'github-actions', 'copilot'];
            if (commenter.type === 'Bot' || excludedBots.some(bot => commenter.login.toLowerCase().includes(bot.toLowerCase()))) {
              return core.info(`Skipping bot: ${commenter.login}`);
            }

            const { pr, linkedIssues } = await getLinkedIssues(context.payload.issue.number);
            if (linkedIssues.size === 0) return core.info('No linked issues');

            const commentId = context.payload.comment.id;
            const marker = `<!-- pr-comment-sync: ${commentId} -->`;

            // Handle delete
            if (context.payload.action === 'deleted') {
              for (const issueNumber of linkedIssues) {
                try {
                  const synced = await findSyncedComment(issueNumber, marker);
                  if (synced) {
                    await github.rest.issues.deleteComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: synced.id
                    });
                    core.info(`Deleted from issue #${issueNumber}`);
                  }
                } catch (error) {
                  core.error(`Delete failed for issue #${issueNumber}: ${error.message}`);
                }
              }
              return;
            }

            // Handle create/edit
            await syncToIssues(
              context.payload.issue.number, linkedIssues, context.payload.comment.body || '',
              marker, 'Update from', commenter, context.payload.action === 'edited'
            );